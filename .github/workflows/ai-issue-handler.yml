name: AI Issue Handler

on:
  issues:
    types: [opened, labeled]
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      min_upvotes:
        description: 'Minimum upvotes required'
        required: false
        default: '1'
      ai_context:
        description: 'AI context for Copilot'
        required: false
        default: |
          This is a React hook for form management.
          The main file is lib/useForm.ts.
          Follow React best practices and maintain type safety.

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read

env:
  MIN_UPVOTES: ${{ github.event.inputs.min_upvotes || vars.DEFAULT_MIN_UPVOTES || 1 }}
  AI_CONTEXT: ${{ github.event.inputs.ai_context || 'Default AI context' }}

jobs:
  handle-issue:
    runs-on: ubuntu-latest
    outputs:
      branch_name: ${{ steps.create-fix-branch.outputs.branch_name }}
      issue_number: ${{ steps.count-upvotes.outputs.issue_number }}
      result: ${{ steps.count-upvotes.outputs.result }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18

      - name: Count upvotes
        id: count-upvotes
        uses: actions/github-script@v6
        with:
          debug: true
          script: |
            // Skip comments made by the repo owner that were created by our workflow
            // This prevents infinite loops when the PR_TOKEN comments as the owner
            if (context.payload.comment && 
                context.payload.comment.user.login === context.repo.owner &&
                context.payload.comment.body.includes("I've created PR #")) {
              console.log('Skipping comment made by workflow to prevent infinite loop');
              return core.setOutput('result', 'false');
            }
            
            try {
              console.log('Context payload:', JSON.stringify(context.payload));
              
              let issueNumber = null;
              if (context.payload.issue) {
                issueNumber = context.payload.issue.number;
              } else if (context.payload.comment) {
                issueNumber = context.payload.comment.issue_number;
              } else {
                console.log('No issue or comment found in payload');
                core.setOutput('result', 'false');
                return false;
              }
              
              console.log(`Fetching issue #${issueNumber}`);
              const { data: issue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });
              
              // Skip processing if the issue is not open
              if (issue.state !== 'open') {
                console.log(`Issue #${issueNumber} is not open (state: ${issue.state}). Skipping.`);
                core.setOutput('result', 'false');
                return false;
              }
              
              console.log(`Issue title: ${issue.title}`);
              console.log(`Issue body: ${issue.body}`);
              
              // Store issue details for other steps
              core.setOutput('issue_title', issue.title);
              core.setOutput('issue_body', issue.body);

              console.log(`Issue reactions: ${JSON.stringify(issue.reactions)}`);
              
              const upvotes = issue.reactions ? issue.reactions['+1'] : 0;
              const threshold = parseInt(process.env.MIN_UPVOTES || 1);
              
              console.log(`Upvotes: ${upvotes}, Threshold: ${threshold}`);
              const result = upvotes >= threshold;
              
              core.setOutput('issue_number', issueNumber.toString());
              core.setOutput('result', result.toString());
              return result;
            } catch (error) {
              console.log(`Error details: ${error.stack}`);
              core.setFailed(`Error counting upvotes: ${error.message}`);
              core.setOutput('result', 'false');
              return false;
            }

      - name: Get issue details
        if: steps.count-upvotes.outputs.result == 'true'
        id: get-issue
        uses: actions/github-script@v6
        with:
          script: |
            const issueNumber = ${{ steps.count-upvotes.outputs.issue_number }};
            
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            console.log(`Issue title: ${issue.title}`);
            console.log(`Issue body: ${issue.body}`);
            
            // Store issue details for other steps
            core.setOutput('issue_title', issue.title);
            core.setOutput('issue_body', issue.body);

      - name: Create fix branch
        if: steps.count-upvotes.outputs.result == 'true'
        id: create-fix-branch
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"
          
          ISSUE_NUMBER="${{ steps.count-upvotes.outputs.issue_number }}"
          TIMESTAMP=$(date +%s)
          BRANCH_NAME="fix/issue-${ISSUE_NUMBER}-${TIMESTAMP}"
          
          git checkout -b $BRANCH_NAME
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Create Copilot prompt
        if: steps.count-upvotes.outputs.result == 'true'
        run: |
          mkdir -p .github/copilot
          cat > .github/copilot/prompt.md << EOF
          # AI Request: Fix issue #${{ steps.count-upvotes.outputs.issue_number }}
          
          ## Issue title
          ${{ steps.get-issue.outputs.issue_title }}
          
          ## User request (use this as the primary prompt)
          ${{ steps.get-issue.outputs.issue_body }}
          
          ## Context information (keep this in mind)
          ${{ env.AI_CONTEXT }}
          
          ## Task
          Based on the user's request above, modify the src/lib/useForm.ts file to implement the requested feature or fix the reported issue.
          Make the changes directly responsive to what the user is asking for in their issue.
          EOF

      - name: Apply simulated AI fix
        if: steps.count-upvotes.outputs.result == 'true'
        id: apply-fix
        run: |
          ISSUE_NUMBER="${{ steps.count-upvotes.outputs.issue_number }}"
          ISSUE_TITLE="${{ steps.get-issue.outputs.issue_title }}"
          ISSUE_BODY="${{ steps.get-issue.outputs.issue_body }}"
          
          # Check if the target file exists
          if [ -f "src/lib/useForm.ts" ]; then
            FILE_PATH="src/lib/useForm.ts"
          else
            echo "Error: Could not find useForm.ts file"
            exit 1
          fi
          
          # Create a temporary file for modifications
          TMP_FILE=$(mktemp)
          
          # Add header with issue reference and user request
          echo "// AI Fix for issue #$ISSUE_NUMBER: $ISSUE_TITLE" > $TMP_FILE
          echo "// Based on user request: ${ISSUE_BODY:0:100}..." >> $TMP_FILE
          echo "" >> $TMP_FILE
          
          # For demonstration purposes, we'll make a simple but meaningful improvement
          # This simulates how an AI would respond to the issue body as a prompt
          
          # Add validation mode option - a common request for form libraries
          cat $FILE_PATH | sed 's/export interface UseFormOptions<T extends Record<string, FormFieldValue>> {/export interface UseFormOptions<T extends Record<string, FormFieldValue>> {\n  \/** When to trigger validation: onBlur, onChange, onSubmit, or manual *\/\n  validationMode?: "onBlur" | "onChange" | "onSubmit" | "manual";/' >> $TMP_FILE
          
          # Update handleSubmit to include better error handling and optional reset
          sed -i 's/await onSubmit(submissionValues);/try {\n            const result = await onSubmit(submissionValues);\n            return result;\n          } catch (error) {\n            console.error("Form submission error:", error);\n            throw error;\n          }/' $TMP_FILE
          
          # Replace the original file with the modified version
          mv $TMP_FILE $FILE_PATH
          
          echo "Applied improvements based on user's issue request"
          
          # Mark as modified
          echo "modified_file=$FILE_PATH" >> $GITHUB_OUTPUT

      - name: Commit and push changes
        if: steps.count-upvotes.outputs.result == 'true'
        run: |
          git add ${{ steps.apply-fix.outputs.modified_file }}
          git commit -m "Fix: ${{ steps.get-issue.outputs.issue_title }} (#${{ steps.count-upvotes.outputs.issue_number }})"
          git push -u origin ${{ steps.create-fix-branch.outputs.branch_name }}

      - name: Get default branch
        if: steps.count-upvotes.outputs.result == 'true'
        id: default-branch
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.PR_TOKEN }}
          script: |
            const { data: repo } = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            console.log(`Repository default branch: ${repo.default_branch}`);
            core.setOutput('default_branch', repo.default_branch);

      - name: Create PR
        id: create-pr
        if: steps.count-upvotes.outputs.result == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.PR_TOKEN }}
          script: |
            const branchName = '${{ steps.create-fix-branch.outputs.branch_name }}';
            const issueNumber = ${{ steps.count-upvotes.outputs.issue_number }};
            const defaultBranch = '${{ steps.default-branch.outputs.default_branch }}';
            
            console.log(`Creating PR for branch: ${branchName} and issue #${issueNumber}`);
            console.log(`Target branch: ${defaultBranch}`);
            
            const { data: pullRequest } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Fix: ${{ steps.get-issue.outputs.issue_title }}`,
              body: `AI-generated fix for issue #${issueNumber}\n\n${{ steps.get-issue.outputs.issue_body }}\n\nThis PR was automatically generated by the AI Issue Handler workflow.`,
              head: branchName,
              base: defaultBranch
            });
            
            console.log(`Created PR #${pullRequest.number}: ${pullRequest.html_url}`);
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: `I've created PR #${pullRequest.number} with an AI-generated fix for this issue: ${pullRequest.html_url}`
            });
            
            // Close the associated issue
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              state: 'closed',
              state_reason: 'completed'
            });
            
            console.log(`Closed issue #${issueNumber} as PR #${pullRequest.number} has been created`);
            
            core.setOutput('pull_request_number', pullRequest.number.toString());

  merge-pr:
    runs-on: ubuntu-latest
    needs: handle-issue
    if: needs.handle-issue.outputs.result == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Count PR upvotes
        id: count-pr-upvotes
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.PR_TOKEN }}
          script: |
            try {
              console.log('Context payload:', JSON.stringify(context.payload));
              
              // Handle both workflow dispatch and PR events
              let prNumber;
              if (context.payload.pull_request) {
                prNumber = context.payload.pull_request.number;
              } else if (context.payload.issue && context.payload.issue.pull_request) {
                prNumber = context.payload.issue.number;
              } else {
                // Get the latest PR from the previous job if called via workflow_dispatch
                const { data: prs } = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open',
                  sort: 'created',
                  direction: 'desc',
                  per_page: 1
                });
                
                if (prs.length === 0) {
                  console.log('No open PRs found');
                  return false;
                }
                
                prNumber = prs[0].number;
              }
              
              console.log(`Checking upvotes for PR #${prNumber}`);
              
              // Get PR details including reactions
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              // Get PR issue to count reactions (PR reactions API is different)
              const { data: prIssue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
              });
              
              console.log(`PR reactions: ${JSON.stringify(prIssue.reactions)}`);
              
              // Count upvotes from reactions
              const upvotes = prIssue.reactions ? prIssue.reactions['+1'] : 0;
              
              // Also count upvotes from comments with 👍
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
              });
              
              // Count comments that contain 👍 or +1
              const commentsWithUpvotes = comments.filter(comment => 
                comment.body.includes('👍') || 
                comment.body.includes(':+1:') || 
                /\+1\b/.test(comment.body)
              ).length;
              
              const totalUpvotes = upvotes + commentsWithUpvotes;
              const threshold = parseInt(process.env.MIN_UPVOTES || 1);
              
              console.log(`PR upvotes: ${totalUpvotes} (${upvotes} reactions + ${commentsWithUpvotes} comments), Threshold: ${threshold}`);
              
              const result = totalUpvotes >= threshold;
              core.setOutput('result', result.toString());
              core.setOutput('pr_number', prNumber.toString());
              
              return result;
            } catch (error) {
              console.log(`Error counting PR upvotes: ${error.stack}`);
              core.setFailed(`Error counting PR upvotes: ${error.message}`);
              return false;
            }

      - name: Merge PR
        if: steps.count-pr-upvotes.outputs.result == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.PR_TOKEN }}
          script: |
            try {
              const prNumber = steps.count-pr-upvotes.outputs.pr_number;
              
              console.log(`Merging PR #${prNumber}`);
              
              const { data: mergeResult } = await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: parseInt(prNumber),
                merge_method: 'merge',
                commit_title: `Merge PR #${prNumber}: AI-generated fix`,
                commit_message: `Automatically merging PR with AI-generated fix after receiving ${process.env.MIN_UPVOTES} upvotes.`
              });
              
              console.log(`Merge result: ${JSON.stringify(mergeResult)}`);
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(prNumber),
                body: `This PR has been automatically merged after receiving ${process.env.MIN_UPVOTES} upvotes.`
              });
              
            } catch (error) {
              console.log(`Error merging PR: ${error.stack}`);
              core.setFailed(`Error merging PR: ${error.message}`);
            }
