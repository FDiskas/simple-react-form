# Workflow name
name: AI Issue Handler V2

# Triggers for the workflow
on:
  # When an issue is opened or labeled with 'ai-fix'
  issues:
    types: [opened, labeled]
  # Allow manual triggering with optional inputs
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process manually'
        required: true
      min_issue_upvotes:
        description: 'Minimum issue upvotes required'
        required: false
        default: '1'
      min_pr_upvotes:
        description: 'Minimum PR upvotes required for auto-merge'
        required: false
        default: '1'
      ai_context:
        description: 'Additional context for the AI'
        required: false
        default: |
          This is a React hook for form management.
          The main file is src/lib/useForm.ts.
          Follow React best practices, maintain type safety, and add necessary comments.
      target_file:
        description: 'File path for AI to modify'
        required: false
        default: 'src/lib/useForm.ts'
      ai_reviewer:
        description: 'GitHub username or team slug for AI review (e.g., github-copilot[bot] or org/copilot-team)'
        required: false
        default: 'copilot' # Defaulting to 'copilot' team slug
      openai_model:
        description: 'OpenAI model to use (e.g., gpt-4, gpt-3.5-turbo)'
        required: false
        default: 'gpt-4' # Or 'gpt-3.5-turbo' for faster/cheaper generation

# Permissions required by the workflow
permissions:
  contents: write         # To checkout code, commit, push, create branches, merge PRs
  issues: write           # To read issues, comment on issues, close issues
  pull-requests: write    # To create PRs, comment on PRs, request reviewers, merge PRs
  actions: read           # To read workflow inputs/variables

# Environment variables available to all jobs
env:
  # Minimum upvotes (+1 reactions) required on the ISSUE to trigger a PR
  MIN_ISSUE_UPVOTES: ${{ github.event.inputs.min_issue_upvotes || vars.DEFAULT_MIN_ISSUE_UPVOTES || 1 }}
  # Minimum upvotes (+1 reactions/comments) required on the PR to trigger auto-merge
  MIN_PR_UPVOTES: ${{ github.event.inputs.min_pr_upvotes || vars.DEFAULT_MIN_PR_UPVOTES || 1 }}
  # Context provided to the AI model
  AI_CONTEXT: "${{ github.event.inputs.ai_context || 'Default AI context: Please adhere to project conventions.' }}"
  # The file the AI should modify
  TARGET_FILE: ${{ github.event.inputs.target_file || 'src/lib/useForm.ts' }}
  # The user or team to request review from
  AI_REVIEWER: ${{ github.event.inputs.ai_reviewer || 'copilot' }}
  # OpenAI Model
  OPENAI_MODEL: ${{ github.event.inputs.openai_model || 'gpt-4' }}
  # Use a Personal Access Token (PAT) with necessary scopes for cross-workflow triggers or advanced operations if needed
  # GITHUB_TOKEN has limitations in triggering other workflows.
  ACTION_PAT: ${{ secrets.ACTION_PAT || secrets.GITHUB_TOKEN }} # Fallback to GITHUB_TOKEN if PAT not set

jobs:
  # Job 1: Process the issue, generate AI fix, and create a PR
  process_issue:
    runs-on: ubuntu-latest
    # Outputs for use in subsequent jobs
    outputs:
      pr_number: ${{ steps.create_pr.outputs.pull_request_number }}
      branch_name: ${{ steps.create_branch.outputs.branch_name }}
      processed_issue_number: ${{ steps.check_issue.outputs.issue_number }}
      should_run_merge_job: ${{ steps.create_pr.outputs.created_pr == 'true' }} # Signal if PR was created

    steps:
      # Step 1: Checkout the repository code
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # Fetch full history, which might be useful for AI context or merge conflict resolution
          fetch-depth: 0

      # Step 2: Setup Node.js (only if your scripts or AI tools require it - remove if not needed)
      # - name: Setup Node.js
      #   uses: actions/setup-node@v4
      #   with:
      #     node-version: 18 # Or the version required by your tools

      # Step 3: Check Issue Details and Upvotes
      - name: Check Issue Details & Upvotes
        id: check_issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PR_TOKEN }} # Use PAT for potentially broader API access
          script: |
            const minUpvotes = parseInt(process.env.MIN_ISSUE_UPVOTES);
            let issueNumber;

            // Determine issue number based on trigger event
            if (context.eventName === 'workflow_dispatch') {
              issueNumber = parseInt(context.payload.inputs.issue_number);
              if (isNaN(issueNumber)) {
                 core.setFailed(`Invalid issue number provided via workflow_dispatch: ${context.payload.inputs.issue_number}`);
                 return;
              }
              console.log(`Processing issue #${issueNumber} via workflow_dispatch.`);
            } else if (context.payload.issue) {
              issueNumber = context.payload.issue.number;
              console.log(`Processing issue #${issueNumber} triggered by issue event '${context.payload.action}'.`);
              // If triggered by 'labeled', check if the label is 'ai-fix' (or your desired label)
              if (context.payload.action === 'labeled' && context.payload.label.name !== 'ai-fix') {
                 console.log(`Issue #${issueNumber} was labeled with '${context.payload.label.name}', not 'ai-fix'. Skipping.`);
                 core.setOutput('should_process', 'false');
                 return;
              }
            } else {
              console.log('Workflow triggered by unexpected event or payload structure. Cannot determine issue number.');
              core.setFailed('Could not determine the issue number from the event payload.');
              return;
            }

            core.setOutput('issue_number', issueNumber.toString());

            // Fetch issue details
            try {
              const { data: issue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
              });

              console.log(`Issue Title: ${issue.title}`);
              // console.log(`Issue Body:\n${issue.body}`); // Log body if needed for debugging, can be long
              console.log(`Issue State: ${issue.state}`);
              console.log(`Issue Reactions (+1): ${issue.reactions?.['+1'] || 0}`);

              // --- Gate Checks ---
              // 1. Check if the issue is open
              if (issue.state !== 'open') {
                console.log(`Issue #${issueNumber} is not open (state: ${issue.state}). Skipping.`);
                core.setOutput('should_process', 'false');
                return;
              }

              // 2. Check for minimum upvotes
              const upvotes = issue.reactions?.['+1'] || 0;
              if (upvotes < minUpvotes) {
                console.log(`Issue #${issueNumber} has ${upvotes} upvotes, but requires ${minUpvotes}. Skipping.`);
                core.setOutput('should_process', 'false');
                return;
              }
              // --- End Gate Checks ---

              console.log(`Issue #${issueNumber} meets criteria (${upvotes}/${minUpvotes} upvotes, state: open). Proceeding.`);
              core.setOutput('should_process', 'true');
              core.setOutput('issue_title', issue.title);
              // Pass the full body to the next step via environment variable if possible,
              // otherwise use outputs (limited length). Using env var is better here.
              // Escape newlines for multiline env var
              const issueBody = issue.body || '';
              const escapedBody = issueBody.replace(/%/g, '%25').replace(/\n/g, '%0A').replace(/\r/g, '%0D');
              console.log(`::set-output name=issue_body::${escapedBody}`);
              // Also set title as output for commit message use later
              const escapedTitle = issue.title.replace(/%/g, '%25').replace(/\n/g, '%0A').replace(/\r/g, '%0D');
               console.log(`::set-output name=issue_title::${escapedTitle}`);


            } catch (error) {
              console.error(`Error fetching or checking issue #${issueNumber}: ${error.message}`);
              console.error(error.stack);
              core.setFailed(`Failed to process issue #${issueNumber}: ${error.message}`);
              core.setOutput('should_process', 'false');
            }
      # Step 4: Create a new branch for the fix
      - name: Create Fix Branch
        id: create_branch
        if: steps.check_issue.outputs.should_process == 'true'
        run: |
          git config --global user.name "GitHub Actions AI Bot"
          git config --global user.email "actions@github.com"

          ISSUE_NUMBER="${{ steps.check_issue.outputs.issue_number }}"
          # Sanitize title slightly for branch name (remove special chars, limit length)
          # Decode the escaped title from the previous step output
          DECODED_TITLE=$(echo "${{ steps.check_issue.outputs.issue_title }}" | python -c "import sys, urllib.parse; print(urllib.parse.unquote(sys.stdin.read()))")
          SANITIZED_TITLE=$(echo "$DECODED_TITLE" | sed 's/[^a-zA-Z0-9-]/-/g' | cut -c 1-50)
          TIMESTAMP=$(date +%s)
          BRANCH_NAME="ai-fix/issue-${ISSUE_NUMBER}-${SANITIZED_TITLE}-${TIMESTAMP}"

          # Ensure base branch is up-to-date before branching
          # DEFAULT_BRANCH=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5)
          # git checkout $DEFAULT_BRANCH
          # git pull origin $DEFAULT_BRANCH

          git checkout -b $BRANCH_NAME
          echo "Created branch: $BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      # ====================================================================
      # Step 5: Apply AI Fix using OpenAI API
      # ====================================================================
      - name: Apply AI Fix via OpenAI
        id: apply_ai_fix
        if: steps.check_issue.outputs.should_process == 'true'
        env:
          # Provide necessary data to the Python script via environment variables
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          TARGET_FILE: ${{ env.TARGET_FILE }}
          ISSUE_TITLE: ${{ steps.check_issue.outputs.issue_title }} # Decoded in Python
          ISSUE_BODY: ${{ steps.check_issue.outputs.issue_body }}   # Decoded in Python
          AI_CONTEXT: ${{ env.AI_CONTEXT }}
          OPENAI_MODEL: ${{ env.OPENAI_MODEL }}
        run: |
          pip install openai==1.* # Install the latest V1 openai library

          # Use python3 explicitly
          python3 << 'EOF'
          import os
          import sys
          import re
          import urllib.parse
          from openai import OpenAI, RateLimitError, APIError

          # --- Configuration ---
          target_file_path = os.getenv('TARGET_FILE')
          openai_api_key = os.getenv('OPENAI_API_KEY')
          # Decode potentially URL-encoded env vars from github-script output
          issue_title = urllib.parse.unquote(os.getenv('ISSUE_TITLE', ''))
          issue_body = urllib.parse.unquote(os.getenv('ISSUE_BODY', ''))
          ai_context = os.getenv('AI_CONTEXT', '')
          model_name = os.getenv('OPENAI_MODEL', 'gpt-4') # Default to gpt-4

          # Basic validation
          if not target_file_path:
              print("::error::TARGET_FILE environment variable not set.")
              sys.exit(1)
          if not openai_api_key:
              print("::error::OPENAI_API_KEY secret not set.")
              sys.exit(1)
          if not issue_body:
              print("::warning::Issue body is empty.")
              # Decide if you want to fail or proceed with just title/context
              # sys.exit(1)

          print(f"Target file: {target_file_path}")
          print(f"Using OpenAI model: {model_name}")

          # --- Read Target File ---
          try:
              with open(target_file_path, 'r', encoding='utf-8') as f:
                  original_content = f.read()
              print(f"Read {len(original_content)} characters from {target_file_path}")
          except FileNotFoundError:
              print(f"::error::Target file '{target_file_path}' not found.")
              sys.exit(1)
          except Exception as e:
              print(f"::error::Failed to read target file '{target_file_path}': {e}")
              sys.exit(1)

          # --- Construct Prompt ---
          # This prompt structure is crucial for good results. Adjust as needed.
          system_prompt = f"""You are an AI programming assistant integrated into a GitHub Actions workflow.
          Your task is to modify the provided code file based on a GitHub issue request.
          Follow these instructions carefully:
          1.  Analyze the user's request (from the issue body) and the provided code context.
          2.  Modify the code in '{target_file_path}' to address the issue.
          3.  Adhere to the additional context: {ai_context}
          4.  IMPORTANT: Output ONLY the complete, modified code for the file '{target_file_path}'.
          5.  Do NOT include any explanations, apologies, introductions, or markdown formatting (like ```typescript ... ```) around the code.
          6.  If the request is ambiguous or cannot be fulfilled, respond with the original code unmodified.
          7.  Ensure the generated code is syntactically correct and maintains existing style conventions.
          """

          user_prompt = f"""GitHub Issue Title: {issue_title}

          GitHub Issue Body (User Request):
          ---
          {issue_body}
          ---

          Current content of '{target_file_path}':
          ---
          {original_content}
          ---

          Please provide the complete, modified code for '{target_file_path}' based *only* on the issue description and context. Remember to output ONLY the raw code.
          """

          # --- Call OpenAI API ---
          modified_content = None
          try:
              print("Calling OpenAI API...")
              client = OpenAI(api_key=openai_api_key) # Uses OPENAI_API_KEY env var by default
              response = client.chat.completions.create(
                  model=model_name,
                  messages=[
                      {"role": "system", "content": system_prompt},
                      {"role": "user", "content": user_prompt},
                  ],
                  temperature=0.2, # Lower temperature for more deterministic code generation
                  # max_tokens=... # Optional: set a limit if needed
              )

              if response.choices:
                  modified_content = response.choices[0].message.content.strip()
                  print(f"Received {len(modified_content)} characters from OpenAI.")
                  # Simple check to remove potential markdown code fences if the model ignored instructions
                  modified_content = re.sub(r'^```[a-zA-Z]*\n?', '', modified_content) # Remove opening fence
                  modified_content = re.sub(r'\n?```$', '', modified_content) # Remove closing fence
                  modified_content = modified_content.strip() # Strip again after removing fences
              else:
                  print("::warning::OpenAI response did not contain any choices.")

          except RateLimitError:
              print("::error::OpenAI API rate limit exceeded. Please check your plan and usage.")
              sys.exit(1)
          except APIError as e:
              print(f"::error::OpenAI API error: {e}")
              sys.exit(1)
          except Exception as e:
              print(f"::error::An unexpected error occurred during the OpenAI API call: {e}")
              sys.exit(1)

          # --- Process Response and Write File ---
          if modified_content and modified_content != original_content:
              print(f"AI generated new content. Writing to {target_file_path}")
              try:
                  with open(target_file_path, 'w', encoding='utf-8') as f:
                      f.write(modified_content)
                  # Set outputs for subsequent steps
                  print(f"::set-output name=modified::true")
                  print(f"::set-output name=modified_file::{target_file_path}")
                  print("Successfully applied AI modifications.")
              except Exception as e:
                  print(f"::error::Failed to write modified content to '{target_file_path}': {e}")
                  # Attempt to restore original content on write failure? Maybe not, state is uncertain.
                  print(f"::set-output name=modified::false") # Mark as not modified if write fails
                  sys.exit(1)
          elif modified_content == original_content:
              print("AI returned the original content. No changes applied.")
              print(f"::set-output name=modified::false")
          else:
              print("::warning::AI did not return valid content. No changes applied.")
              print(f"::set-output name=modified::false")

          EOF # End of Python script

      # Step 6: Commit and Push Changes
      - name: Commit and Push Changes
        # Use the output from the AI step's ID
        if: steps.apply_ai_fix.outputs.modified == 'true'
        run: |
          MODIFIED_FILE="${{ steps.apply_ai_fix.outputs.modified_file }}"
          echo "Adding $MODIFIED_FILE to git staging area."
          git add "$MODIFIED_FILE"

          ISSUE_NUMBER="${{ steps.check_issue.outputs.issue_number }}"
          # Decode title again for the commit message
          DECODED_TITLE=$(echo "${{ steps.check_issue.outputs.issue_title }}" | python -c "import sys, urllib.parse; print(urllib.parse.unquote(sys.stdin.read()))")
          COMMIT_MSG="feat(ai): Apply AI fix for issue #${ISSUE_NUMBER} - ${DECODED_TITLE}"

          echo "Committing changes with message: $COMMIT_MSG"
          # Use 'git commit' exit code to check if commit was successful
          if git commit -m "$COMMIT_MSG"; then
             echo "Changes committed."
             git push -u origin ${{ steps.create_branch.outputs.branch_name }}
             echo "Changes pushed to branch ${{ steps.create_branch.outputs.branch_name }}"
             echo "committed=true" >> $GITHUB_OUTPUT
          else
             echo "Commit failed - likely no changes detected after 'git add'."
             echo "committed=false" >> $GITHUB_OUTPUT
          fi

      # Step 7: Get Default Branch Name
      - name: Get Default Branch
        id: default_branch
        # Run only if changes were committed
        if: steps.commit_and_push.outputs.committed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PR_TOKEN }}
          script: |
            const { data: repo } = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            console.log(`Repository default branch: ${repo.default_branch}`);
            core.setOutput('default_branch', repo.default_branch);

      # Step 8: Create Pull Request
      - name: Create Pull Request
        id: create_pr
        # Run only if changes were committed
        if: steps.commit_and_push.outputs.committed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PR_TOKEN }} # Use PAT to ensure permissions and trigger potential other workflows
          script: |
            const branchName = '${{ steps.create_branch.outputs.branch_name }}';
            const issueNumber = ${{ steps.check_issue.outputs.issue_number }};
            const defaultBranch = '${{ steps.default_branch.outputs.default_branch }}';
            // Decode title and body directly in the script
            const issueTitle = decodeURIComponent('${{ steps.check_issue.outputs.issue_title }}'.replace(/\+/g, ' '));
            const issueBody = decodeURIComponent('${{ steps.check_issue.outputs.issue_body }}'.replace(/\+/g, ' '));
            const aiReviewer = process.env.AI_REVIEWER;

            console.log(`Creating PR for branch: ${branchName} targeting ${defaultBranch}`);
            console.log(`Related Issue: #${issueNumber}`);

            // Escape backticks for the PR body markdown code block
            const escapedIssueBody = issueBody.replace(/`/g, '\\`');

            try {
              const { data: pullRequest } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `feat(ai): Fix issue #${issueNumber} - ${issueTitle}`,
                body: `This PR provides an AI-generated solution for issue #${issueNumber}.\n\n**Original Issue Request:**\n\n\`\`\`\n${escapedIssueBody}\n\`\`\`\n\nCloses #${issueNumber}`, // Automatically closes issue when PR merges
                head: branchName,
                base: defaultBranch,
                draft: false // Set to true if you want draft PRs first
              });

              console.log(`Created PR #${pullRequest.number}: ${pullRequest.html_url}`);
              core.setOutput('pull_request_number', pullRequest.number.toString());
              core.setOutput('created_pr', 'true'); # Signal that PR was created

              // Add comment to the original issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `✅ AI has created PR #${pullRequest.number} to address this issue: ${pullRequest.html_url}`
              });
              console.log(`Commented on issue #${issueNumber}`);

              // Request review
              if (aiReviewer) {
                try {
                  // Check if reviewer is likely a team slug (contains '/')
                  let reviewers = [];
                  let team_reviewers = [];
                  if (aiReviewer.includes('/')) {
                     team_reviewers.push(aiReviewer.split('/').pop()); # Get team slug part
                     console.log(`Requesting review from team: ${team_reviewers[0]}`);
                  } else {
                     reviewers.push(aiReviewer);
                     console.log(`Requesting review from user: ${reviewers[0]}`);
                  }

                  await github.rest.pulls.requestReviewers({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pullRequest.number,
                    reviewers: reviewers,
                    team_reviewers: team_reviewers
                  });
                  console.log(`Successfully requested review from '${aiReviewer}'`);
                } catch (reviewError) {
                  console.warn(`⚠️ Failed to add reviewer '${aiReviewer}': ${reviewError.message}. This might require specific permissions or the user/team may not exist.`);
                }
              } else {
                 console.log("No AI_REVIEWER specified, skipping review request.");
              }

            } catch (error) {
               console.error(`Error creating PR or interacting with issue/reviewers: ${error.stack}`);
               core.setFailed(`Failed to create PR or perform post-creation steps: ${error.message}`);
               core.setOutput('created_pr', 'false');
            }
        # Fallback if previous steps were skipped
        if: steps.check_issue.outputs.should_process != 'true' || steps.apply_ai_fix.outputs.modified != 'true' || steps.commit_and_push.outputs.committed != 'true'
        run: |
          echo "Skipping PR creation because preconditions were not met (issue not processed, AI made no changes, or commit failed)."
          # Ensure output is set even in skipped cases for the 'needs' condition later
          echo "::set-output name=created_pr::false"


  # Job 2: Automatically merge the PR if it gets enough upvotes
  auto_merge_pr:
    runs-on: ubuntu-latest
    # Needs the process_issue job to complete successfully AND have created a PR
    needs: process_issue
    # Only run if the previous job indicated a PR was successfully created
    if: needs.process_issue.outputs.should_run_merge_job == 'true'

    steps:
      # Step 1: Checkout code (might not be strictly necessary but good practice)
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Check PR Status and Upvotes
      - name: Check PR Status & Upvotes
        id: check_pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PR_TOKEN }}
          script: |
            const prNumber = parseInt('${{ needs.process_issue.outputs.pr_number }}');
            const minPrUpvotes = parseInt(process.env.MIN_PR_UPVOTES);

            // Add a delay before checking PR status to allow GitHub API to update (e.g., mergeable state)
            await new Promise(resolve => setTimeout(resolve, 15000)); # 15 seconds delay

            if (isNaN(prNumber)) {
               console.log("PR number is not valid from previous job. Skipping merge check.");
               core.setOutput('should_merge', 'false');
               return;
            }

            console.log(`Checking status and upvotes for PR #${prNumber}`);

            try {
               # Get PR details - Retry logic might be needed if mergeable state is initially null
               let pr;
               let attempts = 0;
               const maxAttempts = 3;
               while (attempts < maxAttempts) {
                  attempts++;
                  const { data: prData } = await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                  });
                  pr = prData;

                  # Check mergeable state specifically
                  if (pr.mergeable === null && attempts < maxAttempts) {
                      console.log(`Mergeable state is null (attempt ${attempts}/${maxAttempts}). Retrying in 10 seconds...`);
                      await new Promise(resolve => setTimeout(resolve, 10000)); # Wait 10 seconds
                      continue; # Retry fetching PR data
                  }
                  # If mergeable is not null or max attempts reached, break loop
                  break;
               }


               # --- Gate Checks ---
               # 1. Check if PR is still open and mergeable
               if (pr.state !== 'open') {
                 console.log(`PR #${prNumber} is not open (state: ${pr.state}). Skipping merge.`);
                 core.setOutput('should_merge', 'false');
                 return;
               }
               if (pr.merged) {
                 console.log(`PR #${prNumber} is already merged. Skipping.`);
                 core.setOutput('should_merge', 'false');
                 return;
               }
               # Check mergeable state after potential retries
               if (pr.mergeable === null) {
                   console.log(`PR #${prNumber} mergeable state is still null after ${maxAttempts} attempts. Skipping merge.`);
                   core.setOutput('should_merge', 'false');
                   return;
               }
               if (pr.mergeable_state === 'blocked' || pr.mergeable_state === 'dirty' || !pr.mergeable) {
                  console.log(`PR #${prNumber} is not mergeable (state: ${pr.mergeable_state}, mergeable: ${pr.mergeable}). Skipping merge.`);
                  # You could add comments here explaining why it's blocked (e.g., failing checks, requested changes)
                  core.setOutput('should_merge', 'false');
                  return;
               }
               # --- End Basic PR State Checks ---


               # --- Upvote Check ---
               # 1. Get reactions on the PR description (treated as an issue)
               const { data: prIssue } = await github.rest.issues.get({
                 owner: context.repo.owner,
                 repo: context.repo.repo,
                 issue_number: prNumber # PRs are also issues
               });
               const reactionUpvotes = prIssue.reactions?.['+1'] || 0;
               console.log(`PR description reactions (+1): ${reactionUpvotes}`);

               # 2. Get comments and check for upvote indicators
               const { data: comments } = await github.rest.issues.listComments({
                 owner: context.repo.owner,
                 repo: context.repo.repo,
                 issue_number: prNumber
               });

               let commentUpvotes = 0;
               const upvotePatterns = [/👍/, /:\+1:/, /\b\+1\b/]; # Regex for +1 word boundary
               for (const comment of comments) {
                 # Avoid counting bot comments if necessary
                 # if (comment.user.type === 'Bot') continue;
                 for (const pattern of upvotePatterns) {
                    if (pattern.test(comment.body)) {
                       commentUpvotes++;
                       break; # Count only one upvote per comment
                    }
                 }
               }
               console.log(`PR comment upvotes (👍, :+1:, +1): ${commentUpvotes}`);

               const totalUpvotes = reactionUpvotes + commentUpvotes;
               console.log(`Total PR upvotes: ${totalUpvotes}, Required: ${minPrUpvotes}`);

               if (totalUpvotes >= minPrUpvotes) {
                 console.log(`PR #${prNumber} meets the upvote threshold. Proceeding to merge.`);
                 core.setOutput('should_merge', 'true');
               } else {
                 console.log(`PR #${prNumber} does not meet the upvote threshold. Skipping merge.`);
                 core.setOutput('should_merge', 'false');
               }
               # --- End Upvote Check ---

            } catch (error) {
               console.error(`Error checking PR #${prNumber} status or upvotes: ${error.stack}`);
               core.warning(`Could not verify PR #${prNumber} for merging: ${error.message}`);
               core.setOutput('should_merge', 'false');
            }

      # Step 3: Merge the Pull Request
      - name: Merge Pull Request
        if: steps.check_pr.outputs.should_merge == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PR_TOKEN }} # PAT likely needed for merge permissions / bypassing branch protection
          script: |
            const prNumber = parseInt('${{ needs.process_issue.outputs.pr_number }}');
            const minPrUpvotes = parseInt(process.env.MIN_PR_UPVOTES);
            const issueNumber = parseInt('${{ needs.process_issue.outputs.processed_issue_number }}');

            console.log(`Attempting to merge PR #${prNumber}`);
            try {
              const { data: mergeResult } = await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'squash', # Or 'merge', 'rebase'
                commit_title: `feat(ai): Fix issue #${issueNumber} (PR #${prNumber})`, # Customize commit title
                commit_message: `Squash merged AI-generated fix after receiving ${minPrUpvotes} or more upvotes.\n\nCloses #${issueNumber}` # Ensure issue is closed by merge commit
              });

              console.log(`Successfully merged PR #${prNumber}. Result: ${mergeResult.message}`);

              # Optional: Comment on the PR after merging
              await github.rest.issues.createComment({
                 owner: context.repo.owner,
                 repo: context.repo.repo,
                 issue_number: prNumber,
                 body: `🚀 This PR was automatically merged after meeting the upvote threshold (${minPrUpvotes}).`
              });

              # Optional: Delete the head branch
              const branchName = '${{ needs.process_issue.outputs.branch_name }}';
              console.log(`Attempting to delete branch: ${branchName}`);
              try {
                 await github.rest.git.deleteRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `heads/${branchName}`
                 });
                 console.log(`Successfully deleted branch ${branchName}`);
              } catch (deleteError) {
                 console.warn(`⚠️ Failed to delete branch ${branchName}: ${deleteError.message}`);
              }

            } catch (error) {
               console.error(`Error merging PR #${prNumber}: ${error.stack}`);
               # Add a comment to the PR indicating failure?
               try {
                  await github.rest.issues.createComment({
                     owner: context.repo.owner,
                     repo: context.repo.repo,
                     issue_number: prNumber,
                     body: `❌ Automatic merge failed: ${error.message}`
                  });
               } catch (commentError) {
                  # Ignore errors trying to comment on failure
               }
               core.setFailed(`Failed to merge PR #${prNumber}: ${error.message}`);
            }
